#include "SHIFTServiceHandler.h"

#include "UserClient.h"

#include <thread>
#include <ctime>

#include <shift/coreclient/CoreClient.h>
#include <shift/coreclient/FIXInitiator.h>
#include <shift/coreclient/Order.h>

#include "DBConnector.h"
#include <nlohmann/json.hpp>
#include <openssl/sha.h>
#include <shift/miscutils/crossguid/Guid.h>

using json = nlohmann::json;

/**
 * @brief: parses out a pRes object result and jsonifies it.
 * @param: pRes, pointer to a pGSQL 
 * @TODO: Probably move this somewhere more multi-purpose? Other modules can utilize this.
 */
json parsePresult(PGresult* pRes){
    json j;
    int rows = PQntuples(pRes);
    int fields = PQnfields(pRes);

    std::vector<std::vector<std::string>> vs;
    for(int row = 0; row < rows; ++row){
        std::vector<std::string> cv;
        for(int field = 0; field < fields; ++field){
            cv.push_back(PQgetvalue(pRes,row,field));
        }
        vs.push_back(cv);
    }

    //This library is pretty cool, huh
    j["rowCount"] = rows;
    j["fieldCount"] = fields;
    j["data"] = vs;

    return j;
}

/**
 * @brief: SHA1 Encrypts a string.
 * @param: str: std::string to encrypt
 * @return: hex representation of the string that has been encrypted
 * @TODO: Probably move this somewhere more multi-purpose? Other modules can utilize this.
 */
std::string encryptStr(std::string str){

    SHA_CTX shactx;

    unsigned char digest[SHA_DIGEST_LENGTH];

    SHA1_Init(&shactx);
    SHA1_Update(&shactx, str.c_str(), sizeof(str.c_str()));
    SHA1_Final(digest, &shactx);

    //C++ stringstreams are the way to go
    std::stringstream strm;
    strm << std::hex << std::setfill('0');
    for(int i =0; i < SHA_DIGEST_LENGTH; i++){
        strm << std::setw(2) << static_cast<int>(digest[i]);
    }
    
    std::string strDigest = strm.str();

    std::cout << strDigest << std::endl;
    std::cout << digest << std::endl;
    return strDigest;
}

/**
 * @brief Method for submitting orders to BC.
 */
void SHIFTServiceHandler::submitOrder(const std::string& username, const std::string& orderType, const std::string& orderSymbol, int32_t orderSize, double orderPrice = 0.0, const std::string& orderID = "")
{
    shift::Order::Type type = shift::Order::Type(orderType[0]);
    shift::Order order(type, orderSymbol, orderSize, orderPrice); // new order IDs are generated by the constructor of Order
    if (type == shift::Order::Type::CANCEL_BID || type == shift::Order::Type::CANCEL_ASK) {
        order.setID(orderID);
    }
    shift::CoreClient* ccptr = shift::FIXInitiator::getInstance().getClient(username);
    if (ccptr)
        ccptr->submitOrder(order);
}

/**
 * @brief Method for sending a list of all active traders, and their properties
 * @param _return Thrift default param that all thrift service functions have in their virtual void funcs
 */
void SHIFTServiceHandler::getAllTraders(std::string& _return){ //NOTE: Thrift modules deposit the result in this _return value param, for more complicated data structs
    //Probably make this last param some kind of default value..?

    PGresult* pRes;

    if(DBConnector::getInstance()->doQuery("SELECT id, username, email, role, super from traders", "FAILED QUERY\n", PGRES_TUPLES_OK, &pRes)){
        std::cout << "RESULTS OBTAINED" << std::endl;
    }
    else{
        std::cout << "COULD NOT GET??" << std::endl;
    }

    std::cout << "Hello from shift!" << std::endl;
    if(DBConnector::b_hasConnected){
        std::cout << "DB has been initialized and is connected!" << std::endl;
    }
    else {
        std::cout << "Oh no...." << std::endl;
    }

    json j;
    j = parsePresult(pRes);
    auto s = j.dump(4);

    _return = s;

    std::cout << "returned... " << s << std::endl;
    //practice proper hygiene ^.^
    PQclear(pRes);
}

/**
 * @brief Method for sending a list of the specified day's rankings
 * @param _return Thrift default param that all thrift service functions have in their virtual void funcs
 * @param dateRange Day of interest for rankings, in the format YYYY-MM-DD
 */
void SHIFTServiceHandler::getThisLeaderboard(std::string& _return, const std::string& startDate, const std::string& endDate){

    PGresult* pRes;

    struct tm tm;

    std::string validatedStart = "";
    std::string query;
    if(strptime(startDate.c_str(), "%Y-%m-%d",&tm) && strptime(endDate.c_str(), "%Y-%m-%d", &tm)){
        std::cout << "valid dates" << std::endl;
        query = std::string("SELECT rank, username, eod_buying_power, eod_traded_shares, eod_pl, eod_earnings, end_date from leaderboard join traders on leaderboard.user_id = traders.id where start_date > '") + startDate + std::string("' and end_date < '") + endDate + std::string("' ORDER BY rank asc;");
    }
    else{
        std::cout << "invalid dates!" << std::endl;
        query = "SELECT rank, username, eod_buying_power, eod_traded_shares, eod_pl, eod_earnings, end_date from leaderboard join traders on leaderboard.user_id = traders.id;";
    }

    if(DBConnector::getInstance()->doQuery(query, "COULD NOT RETRIEVE LEADERBOARD\n", PGRES_TUPLES_OK, &pRes)){
        std::cout << "RESULTS OBTAINED" << std::endl;
    }
    else{
        std::cout << "COULD NOT GET??" << std::endl;
    }

    json j;
    j = parsePresult(pRes);
    auto s = j.dump(4);

    _return = s;

    std::cout << "returned... " << s << std::endl;
    //practice proper hygiene ^.^
    PQclear(pRes);

}

/**
 * @brief Method for sending current username to frontend.
 * @param username The current user who is operating on WebClient.
 */
void SHIFTServiceHandler::webUserLoginV2(std::string& _return, const std::string& username, const std::string& password)
{
    std::cout << password << std::endl;
    PGresult* pRes;
    bool b_found_user = false;
    std::string sessionGuid = "";

    std::string shaPw = encryptStr(password);
    std::string query;
    query = "SELECT * from traders where username = '" + username + "' and password = '" + shaPw + "' LIMIT 1;";
    //std::cout << query << std::endl;
    if(DBConnector::getInstance()->doQuery(query, "COULD NOT RETRIEVE USER\n", PGRES_TUPLES_OK, &pRes)){
        std::cout << "RESULTS OBTAINED" << std::endl;
        b_found_user = true;

        sessionGuid = shift::crossguid::newGuid().str();
        query = "UPDATE traders SET sessionid = '" + sessionGuid + "' WHERE username = '" + username + "';";
        std::cout << query << std::endl;
        if(DBConnector::getInstance()->doQuery(query, "COULD NOT UPDATE SESSION ID\n")){
            std::cout << "new guid: " << sessionGuid << std::endl;
        }        
    }
    else{
        std::cout << "COULD NOT FIND USER" << std::endl;
    }

    if (username == "" && password == "")
        return;

    json j;
    j = parsePresult(pRes);
    j["success"] = b_found_user;
    j["sessionid"] = sessionGuid;

    auto s = j.dump(4);

    std::cout << "returned... " << s << std::endl;
    _return = s;
    /*
    try {
        shift::FIXInitiator::getInstance().getClient(username);
    } catch (...) {
        shift::CoreClient* ccptr = new UserClient(username);
        shift::FIXInitiator::getInstance().attachClient(ccptr);
    }*/
}

void SHIFTServiceHandler::webClientSendUsername(const std::string& username)
{
    return;
}

/**
 * @brief Method for sending current username to frontend.
 * @param username The current user who is operating on WebClient.
 */
void SHIFTServiceHandler::webUserLogin(const std::string& username)
{
    if (username == "")
        return;

    try {
        shift::FIXInitiator::getInstance().getClient(username);
    } catch (...) {
        shift::CoreClient* ccptr = new UserClient(username);
        shift::FIXInitiator::getInstance().attachClient(ccptr);
    }
}

