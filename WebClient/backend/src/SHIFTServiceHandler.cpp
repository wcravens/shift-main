#include "SHIFTServiceHandler.h"

#include "UserClient.h"

#include <thread>
#include <ctime>

#include <shift/coreclient/CoreClient.h>
#include <shift/coreclient/FIXInitiator.h>
#include <shift/coreclient/Order.h>

#include "DBConnector.h"
#include <nlohmann/json.hpp>

using json = nlohmann::json;

/**
 * @brief: parses out a pRes object result and jsonifies it.
 * @param: pRes, pointer to a pGSQL 
 * @TODO: Probably move this somewhere more multi-purpose? Other modules can utilize this.
 */
json parsePresult(PGresult* pRes){
    json j;
    int rows = PQntuples(pRes);
    int fields = PQnfields(pRes);

    std::vector<std::vector<std::string>> vs;
    for(int row = 0; row < rows; ++row){
        std::vector<std::string> cv;
        for(int field = 0; field < fields; ++field){
            cv.push_back(PQgetvalue(pRes,row,field));
        }
        vs.push_back(cv);
    }

    //This library is pretty cool, huh
    j["rowCount"] = rows;
    j["fieldCount"] = fields;
    j["data"] = vs;

    return j;
}

/**
 * @brief Method for submitting orders to BC.
 */
void SHIFTServiceHandler::submitOrder(const std::string& username, const std::string& orderType, const std::string& orderSymbol, int32_t orderSize, double orderPrice = 0.0, const std::string& orderID = "")
{
    shift::Order::Type type = shift::Order::Type(orderType[0]);
    shift::Order order(type, orderSymbol, orderSize, orderPrice); // new order IDs are generated by the constructor of Order
    if (type == shift::Order::Type::CANCEL_BID || type == shift::Order::Type::CANCEL_ASK) {
        order.setID(orderID);
    }
    shift::CoreClient* ccptr = shift::FIXInitiator::getInstance().getClient(username);
    if (ccptr)
        ccptr->submitOrder(order);
}

/**
 * @brief Method for sending a list of all active traders, and their properties
 * @param _return Thrift default param that all thrift service functions have in their virtual void funcs
 */
void SHIFTServiceHandler::getAllTraders(std::string& _return){ //NOTE: Thrift modules deposit the result in this _return value param, for more complicated data structs
    //Probably make this last param some kind of default value..?

    PGresult* pRes;

    if(DBConnector::getInstance()->doQuery("SELECT id, username, email, role, super from traders", "FAILED QUERY\n", PGRES_TUPLES_OK, &pRes)){
        std::cout << "RESULTS OBTAINED" << std::endl;
    }
    else{
        std::cout << "COULD NOT GET??" << std::endl;
    }

    std::cout << "Hello from shift!" << std::endl;
    if(DBConnector::b_hasConnected){
        std::cout << "DB has been initialized and is connected!" << std::endl;
    }
    else {
        std::cout << "Oh no...." << std::endl;
    }

    json j;
    j = parsePresult(pRes);
    auto s = j.dump(4);

    _return = s;

    std::cout << "returned... " << s << std::endl;
    //practice proper hygiene ^.^
    PQclear(pRes);
}

/**
 * @brief Method for sending a list of the specified day's rankings
 * @param _return Thrift default param that all thrift service functions have in their virtual void funcs
 * @param dateRange Day of interest for rankings, in the format YYYY-MM-DD
 */
void SHIFTServiceHandler::getThisLeaderboard(std::string& _return, const std::string& startDate, const std::string& endDate){

    PGresult* pRes;

    struct tm tm;

    std::string validatedStart = "";
    std::string query;
    if(strptime(startDate.c_str(), "%Y-%m-%d",&tm) && strptime(endDate.c_str(), "%Y-%m-%d", &tm)){
        std::cout << "valid dates" << std::endl;
        query = std::string("SELECT * from leaderboard where start_date > '") + startDate + std::string("' and end_date < '") + endDate + std::string("' ORDER BY rank asc;");
    }
    else{
        std::cout << "invalid dates!" << std::endl;
        query = "SELECT * from leaderboard;";
    }

    if(DBConnector::getInstance()->doQuery(query, "COULD NOT RETRIEVE LEADEBOARD\n", PGRES_TUPLES_OK, &pRes)){
        std::cout << "RESULTS OBTAINED" << std::endl;
    }
    else{
        std::cout << "COULD NOT GET??" << std::endl;
    }

    json j;
    j = parsePresult(pRes);
    auto s = j.dump(4);

    _return = s;

    std::cout << "returned... " << s << std::endl;
    //practice proper hygiene ^.^
    PQclear(pRes);

}

/**
 * @brief Method for sending current username to frontend.
 * @param username The current user who is operating on WebClient.
 */
void SHIFTServiceHandler::webUserLogin(const std::string& username)
{
    if (username == "")
        return;

    try {
        shift::FIXInitiator::getInstance().getClient(username);
    } catch (...) {
        shift::CoreClient* ccptr = new UserClient(username);
        shift::FIXInitiator::getInstance().attachClient(ccptr);
    }
}

void SHIFTServiceHandler::webClientSendUsername(const std::string& username)
{
    return;
}
